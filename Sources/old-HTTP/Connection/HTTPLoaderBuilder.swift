//
//  Copyright Â© 2022 Daniel Thorpe. All rights reserved.
//

/// Inspired by Dave de Long's blog series on HTTP
/// https://davedelong.com/blog/2020/06/27/http-in-swift-part-1/

import Foundation

@resultBuilder
public enum HTTPLoaderBuilder {

    @inlinable
    public static func buildBlock<Loader: HTTPLoadable>(
        _ loader: Loader
    ) -> Loader {
        loader
    }

    /// Provides support for `if`-`else` statements in ``HTTPLoaderBuilder``
    /// blocks, producing a conditional loader for the `if` branch.
    @inlinable
    public static func buildEither<TrueLoader, FalseLoader>(
        first loader: TrueLoader
    ) -> Loaders.Conditional<TrueLoader, FalseLoader> {
        .first(loader)
    }

    /// Provides support for `if`-`else` statements in ``HTTPLoaderBuilder``
    /// blocks, producing a conditional loader for the `if` branch.
    @inlinable
    public static func buildEither<TrueLoader, FalseLoader>(
        second loader: FalseLoader
    ) -> Loaders.Conditional<TrueLoader, FalseLoader> {
        .second(loader)
    }

    /// Provides support for `if let` statements in ``HTTPLoaderBuilder``
    /// blocks, producing a conditional loader for the `if` branch.
    @inlinable
    public static func buildIf<Loader: HTTPLoadable>(
        _ loader: Loader?
    ) -> Loader? {
        loader
    }

    /// Provides support for `if #available` statements in ``HTTPLoaderBuilder``
    /// blocks, producing an optional parser.
    @inlinable
    public static func buildLimitedAvailability<Loader: HTTPLoadable>(
        _ loader: Loader?
    ) -> Loader? {
        loader
    }

}

public struct HTTP<Loaders: HTTPLoadable>: HTTPLoadable {
    public let loaders: Loaders
    @inlinable
    public init(@HTTPLoaderBuilder _ build: () -> Loaders) {
        loaders = build()
    }

    public func load(_ request: HTTPRequest) async throws -> HTTPResponse {
        try await loaders.load(request)
    }
}

// MARK: - Loaders to be autogenerated

extension HTTPLoaderBuilder {
    public struct PipelineLL<L0, L1>: HTTPLoadable
    where L0: HTTPLoadable, L1: HTTPLoadable
    {
        public let l0: L0
        public let l1: L1

        @inlinable public init(_ l0: L0, _ l1: L1) {
            self.l0 = l0
            self.l1 = l1
        }

        @inlinable public func load(_ request: HTTPRequest) async throws -> HTTPResponse {
            try await Pipeline([l0, l1]).load(request)
        }
    }

    @inlinable public static func buildBlock<L0, L1>(_ l0: L0, _ l1: L1) -> PipelineLL<L0, L1> {
        .init(l0, l1)
    }
}

extension HTTPLoaderBuilder {
    public struct PipelineLLL<L0, L1, L2>: HTTPLoadable
    where L0: HTTPLoadable, L1: HTTPLoadable, L2: HTTPLoadable
    {
        public let l0: L0
        public let l1: L1
        public let l2: L2

        @inlinable public init(_ l0: L0, _ l1: L1, _ l2: L2) {
            self.l0 = l0
            self.l1 = l1
            self.l2 = l2
        }

        @inlinable public func load(_ request: HTTPRequest) async throws -> HTTPResponse {
            try await Pipeline([l0, l1, l2]).load(request)
        }
    }

    @inlinable public static func buildBlock<L0, L1, L2>(_ l0: L0, _ l1: L1, _ l2: L2) -> PipelineLLL<L0, L1, L2> {
        .init(l0, l1, l2)
    }
}
